---
layout: post
title: "lanugage switching with dynamicly generated i18n urls"
date: 2013-10-17 22:49
comments: true
categories:
---

A while back I ran in to a problem of a client who decided they needed translated routes for SEO resasons. In general this is not too big of a problem and there are great gems and out there to help you.

For instance I used [translate_routes](https://github.com/raul/translate_routes) which will help to translate the "model" part of your routes. e.g:

- English: _/books_
- French: _/livres_

However, in my case some URLs are not defined up front but are instead generated by parameterizing some part/parts of the related resource content. Sticking with the books example "Crime and Punishment" by Fyodor Dostoyevsky could for instance get the URLs:

- English: _/books/crime-and-punishment_.
- French: _/livres/crime-et-chatiment_.

To acchive this I used the [Friendly Id 4.0](https://github.com/norman/friendly_id/tree/4.0-stable) gem that provides integration with [Globalize 3](https://github.com/globalize/globalize) gem that allows for the "slug" for a resouce to be translated and persisted per locale. So while this solves the translation of resource paths, it does not tackle the language switcher that should switch language but display the same content. Allbeit in different language.

So how can one solve this problem in Ruby on Rails.

##Option 1: Adding resource id as initial part of url.

Ryan Bates showed this technique off in [Railscast #63](http://railscasts.com/episodes/63-model-name-in-url). This would work out as follows:

```ruby

#model
def to_param
  "#{id}-#{localized_permalink}"
end
#/books/340-crime-and-punishment
#/livres/340-crime-et-chatiment

#controller
@book = Book.find(params[:id])

#This would allow for simple switcher links

<%= link_to "Fr", {locale: 'fr'} %>
# assuming we're on :en locale this would generate:
# /livres/340-crime-and-punishment
```

This will work but not that you will have multiple URLs to same content which I've been told is aparantly is not the best idea from an SEO standpoint. Please don't quote me on this though. Regardless this was not allowed in the project I was working on.

## Option 2: Translation logic on request.

I've actually not tried this out but you could theoretically do the translation lookup on the request by using the non translated id and other resource_id params. This carries with it the same potential concern as option 1.


## Option 3: Pre-generated translated routes

This is the solution I needed to meet my clients specific demands. What I did here was to add a concern to the models with content specific URLs. The purpouse was to provide my views with a hash for the current resource that contained all translated routes to it. Also note that I had to solve the problem also for nested resources.

some code:
```ruby
module TranslatedRoutes
  extend ActiveSupport::Concern

  def translated_routes(parent = nil)
    paths = {}
    I18n.available_locales.each do |locale|
      paths[locale] = translated_path_for(locale, parent)
    end
    paths
  end

  # { :locale => :en,
  #   :parent_id => parent.id, :id => child.id
  # }
  def translated_path_for(locale, parent = nil)
    path = {:locale => locale.to_s, :id => slug_for(locale)}
    path.merge!({parent.class.to_s.foreign_key => parent.slug_for(locale)}) unless parent.nil?
    path
  end

  # { :en=>"crime-and-punishment",
  #   :fr=>"crime-et-chatiment" }
  def slugs
    Hash[ *translations.map{ |t| [t.locale,t.slug]}.flatten]
  end

  # path_for(:en) => "crime-and-punishment"
  def slug_for(locale)
    if localized_slug = slugs[locale]
      localized_slug
    else
      slug
    end
  end
end


#model
class Book < ActiveRecord::Base
  include TranslatedRoutes
end

#controller
def show
  @book = Book.find params[:id]
  @localized_routes = @book.translated_routes
end

#helper
def localized_path(locale)
  if @localized_routes
    @localized_routes[locale]
  else
    {:locale => locale.to_s}
  end
end

#switcher
<%= link_to "English", localized_path(:en) %>
<%= link_to "French", localized_path(:fr) %>

```

I'm not sure this is the optimal solution for this kind of requirements, however it does seem to work well. If you know of better solutions or optimizations to this please let me know in the comments below.